"""
pokemon_data.py - Handles loading and accessing Pokémon data from CSV
"""

import csv
import json
from typing import Dict, List, Optional, Any
import os


class PokemonDatabase:
    """Database for Pokémon stats and information"""
    
    def __init__(self, csv_path: str = "pokemon.csv"):
        self.pokemon_data = {}
        self.type_effectiveness = {}
        self.csv_path = csv_path
        self.load_data()
    
    def load_data(self):
        """Load Pokémon data from CSV file"""
        if not os.path.exists(self.csv_path):
            print(f"Warning: Pokémon CSV file not found at {self.csv_path}")
            print("Using default Pokémon data...")
            self.create_default_data()
            return
        
        try:
            with open(self.csv_path, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                
                for row in reader:
                    pokedex_num = int(row['pokedex_number'])
                    
                    # Parse abilities (they're in a list format)
                    abilities_str = row['abilities']
                    abilities = []
                    if abilities_str and abilities_str != 'nan':
                        # Remove brackets and quotes, then split
                        abilities = [a.strip().strip("'") for a in 
                                   abilities_str.strip('[]').split(',')]
                    
                    # Parse against_* columns for type effectiveness
                    against_stats = {}
                    for key in row.keys():
                        if key.startswith('against_'):
                            try:
                                against_stats[key] = float(row[key])
                            except ValueError:
                                against_stats[key] = 1.0  # Default
                    
                    # Create Pokémon entry
                    self.pokemon_data[pokedex_num] = {
                        'name': row['name'],
                        'pokedex_number': pokedex_num,
                        'type1': row['type1'],
                        'type2': row['type2'] if row['type2'] and row['type2'] != 'nan' else None,
                        'hp': int(row['hp']),
                        'attack': int(row['attack']),
                        'defense': int(row['defense']),
                        'special_attack': int(row['sp_attack']),
                        'special_defense': int(row['sp_defense']),
                        'speed': int(row['speed']),
                        'abilities': abilities,
                        'height_m': float(row['height_m']) if row['height_m'] != 'nan' else 0,
                        'weight_kg': float(row['weight_kg']) if row['weight_kg'] != 'nan' else 0,
                        'base_total': int(row['base_total']),
                        'capture_rate': int(row['capture_rate']),
                        'classification': row['classfication'],
                        'generation': int(row['generation']),
                        'is_legendary': bool(int(row['is_legendary'])),
                        'against_stats': against_stats
                    }
                    
            print(f"✓ Loaded {len(self.pokemon_data)} Pokémon from {self.csv_path}")
            
        except Exception as e:
            print(f"Error loading Pokémon CSV: {e}")
            print("Using default Pokémon data...")
            self.create_default_data()
    
    def create_default_data(self):
        """Create default Pokémon data if CSV is not available"""
        default_pokemon = {
            1: {
                'name': 'Bulbasaur',
                'pokedex_number': 1,
                'type1': 'grass',
                'type2': 'poison',
                'hp': 45,
                'attack': 49,
                'defense': 49,
                'special_attack': 65,
                'special_defense': 65,
                'speed': 45,
                'abilities': ['Overgrow', 'Chlorophyll'],
                'height_m': 0.7,
                'weight_kg': 6.9,
                'base_total': 318,
                'capture_rate': 45,
                'classification': 'Seed Pokémon',
                'generation': 1,
                'is_legendary': False,
                'against_stats': self.get_default_type_effectiveness(['grass', 'poison'])
            },
            4: {
                'name': 'Charmander',
                'pokedex_number': 4,
                'type1': 'fire',
                'type2': None,
                'hp': 39,
                'attack': 52,
                'defense': 43,
                'special_attack': 60,
                'special_defense': 50,
                'speed': 65,
                'abilities': ['Blaze', 'Solar Power'],
                'height_m': 0.6,
                'weight_kg': 8.5,
                'base_total': 309,
                'capture_rate': 45,
                'classification': 'Lizard Pokémon',
                'generation': 1,
                'is_legendary': False,
                'against_stats': self.get_default_type_effectiveness(['fire'])
            },
            7: {
                'name': 'Squirtle',
                'pokedex_number': 7,
                'type1': 'water',
                'type2': None,
                'hp': 44,
                'attack': 48,
                'defense': 65,
                'special_attack': 50,
                'special_defense': 64,
                'speed': 43,
                'abilities': ['Torrent', 'Rain Dish'],
                'height_m': 0.5,
                'weight_kg': 9.0,
                'base_total': 314,
                'capture_rate': 45,
                'classification': 'Tiny Turtle Pokémon',
                'generation': 1,
                'is_legendary': False,
                'against_stats': self.get_default_type_effectiveness(['water'])
            }
        }
        
        self.pokemon_data = default_pokemon
        print("✓ Loaded default Pokémon data")
    
    def get_default_type_effectiveness(self, types: List[str]) -> Dict[str, float]:
        """Get default type effectiveness multipliers"""
        effectiveness = {
            'against_bug': 1.0,
            'against_dark': 1.0,
            'against_dragon': 1.0,
            'against_electric': 1.0,
            'against_fairy': 1.0,
            'against_fight': 1.0,
            'against_fire': 1.0,
            'against_flying': 1.0,
            'against_ghost': 1.0,
            'against_grass': 1.0,
            'against_ground': 1.0,
            'against_ice': 1.0,
            'against_normal': 1.0,
            'against_poison': 1.0,
            'against_psychic': 1.0,
            'against_rock': 1.0,
            'against_steel': 1.0,
            'against_water': 1.0
        }
        
        # Apply type-specific multipliers
        type_multipliers = {
            'grass': {
                'against_fire': 2.0, 'against_flying': 2.0, 'against_ice': 2.0,
                'against_poison': 2.0, 'against_bug': 2.0, 'against_water': 0.5,
                'against_electric': 0.5, 'against_grass': 0.5, 'against_ground': 0.5
            },
            'poison': {
                'against_ground': 2.0, 'against_psychic': 2.0, 'against_grass': 0.5,
                'against_fight': 0.5, 'against_poison': 0.5, 'against_bug': 0.5,
                'against_fairy': 0.5
            },
            'fire': {
                'against_water': 2.0, 'against_ground': 2.0, 'against_rock': 2.0,
                'against_bug': 0.5, 'against_steel': 0.5, 'against_fire': 0.5,
                'against_grass': 0.5, 'against_ice': 0.5, 'against_fairy': 0.5
            },
            'water': {
                'against_electric': 2.0, 'against_grass': 2.0, 'against_steel': 0.5,
                'against_fire': 0.5, 'against_water': 0.5, 'against_ice': 0.5
            }
        }
        
        for pokemon_type in types:
            if pokemon_type in type_multipliers:
                for stat, multiplier in type_multipliers[pokemon_type].items():
                    effectiveness[stat] *= multiplier
        
        return effectiveness
    
    def get_pokemon_by_name(self, name: str) -> Optional[Dict]:
        """Get Pokémon data by name (case-insensitive)"""
        for pokemon in self.pokemon_data.values():
            if pokemon['name'].lower() == name.lower():
                return pokemon.copy()  # Return a copy to prevent modification
        return None
    
    def get_pokemon_by_number(self, number: int) -> Optional[Dict]:
        """Get Pokémon data by Pokédex number"""
        if number in self.pokemon_data:
            return self.pokemon_data[number].copy()
        return None
    
    def search_pokemon(self, query: str) -> List[Dict]:
        """Search Pokémon by name or number"""
        results = []
        query = query.lower()
        
        for pokemon in self.pokemon_data.values():
            if (query in pokemon['name'].lower() or 
                (query.isdigit() and int(query) == pokemon['pokedex_number'])):
                results.append(pokemon.copy())
        
        return results
    
    def get_type_effectiveness(self, attacking_type: str, defending_types: List[str]) -> float:
        """Calculate type effectiveness multiplier"""
        if not defending_types:
            return 1.0
        
        effectiveness = 1.0
        
        for defending_type in defending_types:
            if not defending_type:
                continue
                
            # Convert type to CSV column format
            type_key = f"against_{defending_type.lower()}"
            
            # Find effectiveness from any Pokémon with these types
            for pokemon in self.pokemon_data.values():
                if (defending_type.lower() == pokemon['type1'].lower() or 
                    (pokemon['type2'] and defending_type.lower() == pokemon['type2'].lower())):
                    
                    if type_key in pokemon['against_stats']:
                        effectiveness *= pokemon['against_stats'][type_key]
                    break
        
        return effectiveness
    
    def get_all_pokemon_names(self) -> List[str]:
        """Get list of all Pokémon names"""
        return [pokemon['name'] for pokemon in self.pokemon_data.values()]
    
    def get_pokemon_list(self, limit: int = None) -> List[Dict]:
        """Get list of Pokémon, optionally limited"""
        pokemon_list = list(self.pokemon_data.values())
        pokemon_list.sort(key=lambda x: x['pokedex_number'])
        
        if limit:
            return pokemon_list[:limit]
        return pokemon_list


# Global instance for easy access
pokemon_db = PokemonDatabase()